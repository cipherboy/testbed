#include "eap-pwd.h"

BIGNUM *get_random_max(BIGNUM *max) {
    BIGNUM *random_scalar = BN_new();
    if (BN_rand_range(random_scalar, max) != 1) {
        DEBUG("Unable to get a random number in the range!");
        return NULL;
    }

    return random_scalar;
}

EC_POINT *get_random_EC_POINT(EC_GROUP *group, BIGNUM *order, BN_CTX *bnctx) {
    BIGNUM *random_scalar = get_random_max(order);

    EC_POINT *random_point = EC_POINT_new(group);
    if (!EC_POINT_mul(group, random_point, random_scalar, NULL, NULL, bnctx)) {
        DEBUG("Error performing point multiplication!");
        free(random_scalar);
        return NULL;
    }

    free(random_scalar);
    return random_point;
}

void print_bn(char *prefix, BIGNUM *num) {
    char *str = BN_bn2hex(num);
    if (prefix != NULL) {
        printf("%s", prefix);
    }
    printf("%s", str);
    if (prefix != NULL) {
        printf("\n");
    }
    free(str);
}

void print_point(char *prefix, EC_GROUP *group, EC_POINT *p, BN_CTX *bnctx) {
    BIGNUM *x = BN_new();
    BIGNUM *y = BN_new();
    char *x_str = NULL;
    char *y_str = NULL;

    if (prefix != NULL) {
        printf("%s", prefix);
    }

    if (EC_POINT_is_at_infinity(group, p)) {
        printf("{0}");
        if (prefix != NULL) {
            printf("\n");
        }
        return;
    }

    if (!EC_POINT_get_affine_coordinates_GFp(group, p, x, y, bnctx)) {
        DEBUG("Unable to get curve points for printing!");
        exit(1);
    }

    x_str = BN_bn2hex(x);
    y_str = BN_bn2hex(y);

    if (prefix != NULL) {
        printf("%s", prefix);
    }
    printf("(%s, %s)", x_str, y_str);
    if (prefix != NULL) {
        printf("\n");
    }

    free(x_str);
    free(y_str);
}

BIGNUM *compute_eap_pwd_scalar(BIGNUM *rand, BIGNUM *mask, BIGNUM *order, BN_CTX *bnctx) {
    BIGNUM *result = BN_new();
    BN_add(result, rand, mask);
    BN_mod(result, result, order, bnctx);

    return result;
}

EC_POINT *compute_eap_pwd_element(EC_POINT *pwe, BIGNUM *mask, EC_GROUP *group, BIGNUM *order, BN_CTX *bnctx) {
    EC_POINT *result = EC_POINT_new(group);

    if (!EC_POINT_mul(group, result, NULL, pwe, mask, bnctx)) {
        DEBUG("Server element allocation failed");
        exit(1);
    }

    if (!EC_POINT_invert(group, result, bnctx)) {
        DEBUG("Server element inversion failed");
        exit(1);
    }

    return result;
}

uint8_t *encode_attack(size_t *ret_len, EC_GROUP *group, BIGNUM *order,
        BIGNUM *prime, EC_POINT *element_p, BIGNUM *scalar_p, BN_CTX *bnctx)
{
    uint8_t *result = NULL;
    uint8_t *ptr = NULL;
    size_t offset = 0;

    if (ret_len == NULL || group == NULL || order == NULL || prime == NULL ||
            element_p == NULL || scalar_p == NULL || bnctx == NULL)
    {
        DEBUG("Must pass ret_len to encode_attack!");
        exit(1);
    }

    BIGNUM *x = BN_new();
    BIGNUM *y = BN_new();

    if (EC_POINT_is_at_infinity(group, element_p)) {
        BN_zero(x);
        BN_zero(y);
    } else if (!EC_POINT_get_affine_coordinates_GFp(group, element_p, x, y, bnctx)) {
        DEBUG("Unable to get curve points for printing!");
        exit(1);
    }

    *ret_len = (size_t)(BN_num_bytes(order) + (2 * BN_num_bytes(prime)));
    result = calloc(*ret_len, sizeof(uint8_t));
    if (result == NULL) {
        DEBUG("Unable to allocate memory!");
        exit(1);
    }

    ptr = result;
    offset = BN_num_bytes(prime) - BN_num_bytes(x);
    BN_bn2bin(x, ptr + offset);
    BN_clear_free(x);

    ptr += BN_num_bytes(prime);
    offset = BN_num_bytes(prime) - BN_num_bytes(y);
    BN_bn2bin(y, ptr + offset);
    BN_clear_free(y);

    ptr += BN_num_bytes(prime);
    offset = BN_num_bytes(order) - BN_num_bytes(scalar_p);
    BN_bn2bin(scalar_p, ptr + offset);


    return result;
}
